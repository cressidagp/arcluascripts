--[[
	ArcLuaScripts for ArcEmu
	www.ArcEmu.org
	Engine: A.L.E
	
	Instance: The Ruby Sanctum
	Boss: Halion the Destroyer (39863)

	Credits:

	*) TrinityCore for texts, sound ids, timers, spell ids and some Inspiration.
	*) Hypersniper for his lua guides and some job in the lua engine.
	*) Paroxysm for his Modular Way of scripting, LCF and Lua Scripting Expected Standards.
	*) ArcEmu developers for ArcEmu and his A.L.E, specially to dfighter1985.
	
	https://www.youtube.com/watch?v=4TwEUrlRLeg
	
	ToDo:

	*) 74637: has a dummy effect (0) but no handler for it.
	*) add localization
	
	enUS locale:
	
	esMX locale:
	
--]]	
	
--local MAP_RUBY_SANCTUM	= 724;

--local NPC_HALION	= 39863;
--local NPC_25M_HALION	= 39864;
--local H_NPC_HALION	= 39944;
--local H_NPC_25M_HALION	= 39945;

--local NPC_TWILIGHT_HALION	= 40142;
--local NPC_25M_TWILIGHT_HALION	= 40143;
--local H_NPC_TWILIGHT_HALION = 40144;
--local H_NPC_25M_TWILIGHT_HALION	= 40145;

--local NPC_CONTROLLER = 40146;

--local NPC_CONTROLLER_ID = 200631;

--local TREES = { 203034, 203035, 203036, 203037 };

--[[ For 3.3.5a
local GAMEOBJECT_BYTES_1		= 0x0006 + 0x000B;
local UNIT_FIELD_FLAGS			= 0x0006 + 0x0035;
local UNIT_FLAG_COMBAT			= 0x00080000;
local UNIT_FLAG_NOT_SELECTABLE	= 0x02000000;
local UNIT_FIELD_FLAGS_2		= 0x0006 + 0x0036;
local UNIT_FLAG2_ENABLE_POWER_REGEN	= 0x0000800;
--]]

--print( "Lua memory before Halion: "..gcinfo().." Kb." );

local mod = getfenv( 1 );
assert( mod );
module( mod._NAME..".HALION_DESTROYER", package.seeall );

--[[local SOUND = {
-- Halion:
[ 1 ] = 17499;  -- Intro -- OK
[ 2 ] = 17500;  -- OnCombat -- OK
[ 3 ] = 17505;  -- OnMeteorStrike -- OK
[ 4 ] = 17507;  -- OnPhaseTwo -- OK
[ 5 ] = 17503;  -- OnDeath -- OK
[ 6 ] = 17501;  -- OnTargetDied -- OK
[ 7 ] = 17504;  -- OnBerserk
-- Twilight:
[ 8 ] = 17506;	-- SpherePulse
[ 9 ] = 17508;	-- OnPhaseThree -- OK
}; --]]

local YELL = {
-- Halion:
[ 1 ] = "Meddlesome insects! You are too late. The Ruby Sanctum is lost!",	-- Intro
[ 2 ] = "The heavens burn!",	-- OnMeterStrike
[ 3 ] = "You will find only suffering within the realm of twilight! Enter if you dare!",	-- OnPhaseTwo
[ 4 ] = "Another \"hero\" falls.",	-- OnTargetDied
[ 5 ] = "Not good enough....",	-- OnBerserk
-- Twilight:
[ 6 ] = "Beware the shadow!",
[ 7 ] = "I am the light and the darkness! Cower, mortals, before the herald of Deathwing!"
};

local TEXT = {
[ 1 ] = "Without pressure in both realms, %s begins to regenerate.",  -- Shared (type 41)
[ 2 ] = "Your efforts force %s further out of the physical realm!", -- (type 41)
[ 3 ] = "Your companions' efforts force %s further into the physical realm!" -- (type 41)
};

-- Spells (Halion):
local SPELL_FLAME_BREATH	= 74525;
local SPELL_METEOR_STRIKE	= 74637; -- aoe?, need a dummy effect
local SPELL_FIERY_COMBUSTION	= 74562;

-- Spells (Twilight Halion):
local SPELL_DARK_BREATH	= 74806;
local SPELL_SOUL_CONSUMPTION	= 74792;

-- Spells (shared):
local SPELL_CLEAVE	= 74524;
local SPELL_TAIL_LASH	= 74531;
local SPELL_TWILIGHT_PRECISION 	= 78243; -- not aura displayed

-- Spells (Halion Controller):
local SPELL_COSMETIC_FIRE_PILLAR	= 76006; -- need a dummy effect and 2 dummys aura effect
local SPELL_FIERY_EXPLOSION = 76010;

-- Handled by Controller:
local SPELL_TWILIGHT_MENDING = 75509;
local SPELL_BERSERK = 26662;

-- Spells (Misc):
local SPELL_LEAVE_TWILIGHT_REALM	= 74812;
local SPELL_TWILIGHT_PHASING	= 74808; -- phase spell from phase 1 to phase 2
local SPELL_TWILIGHT_DIVISION	= 75063; -- phase spell from phase 2 to phase 3
local SPELL_DUSK_SHROUD	= 75476;
local SPELL_COPY_DAMAGE	= 74810;
local SPELL_SUMMON_TWILIGHT_PORTAL	= 74809; -- Summons go 202794
local SPELL_SUMMON_EXIT_PORTALS = 74805;

-- Phases:
local PHASE_ALL		= 0;
local PHASE_INTRO	= 1;
local PHASE_ONE		= 2; -- combat in Physical realm
local PHASE_TWO		= 3; -- combat in Twilight realm
local PHASE_THREE	= 4; -- combat in both realms

local self = getfenv( 1 );

function OnSpawn( unit )

	-- set health acording to difficulty
	local BOSS_HP = { 11156000, 40440500, 15339500, 58569000 };
	
    local diff = unit:GetDungeonDifficulty();
	
    unit:SetMaxHealth( BOSS_HP[ diff + 1 ] );

    unit:SetHealth( BOSS_HP[ diff + 1 ] );
	
	unit:SetFlag( 0x0006 + 0x0036, 0x0000800 );

end

function OnCombat( unit )

	-- create protected variables
	self[ tostring( unit )] = {

	phase = PHASE_ONE,
	cleave = math.random( 6, 10 ),
	tailLash = math.random( 7, 12 ),
	flameBreath = math.random( 5, 15 ),
	flameRingTime = 5,
	meteorStrike = 18,
	fieryCombustion = math.random( 15, 18 )
	
	};

	--[[ Developer notes: we dont need to send the chat here since
    our monstersay table will do the job, instance collision checked. ]]

    unit:PlaySoundToSet( 17500 );

	unit:AddAura( SPELL_TWILIGHT_PRECISION, 0 );
	
	unit:RegisterAIUpdateEvent( 1000 );
	
	-- get controller using spawnid 
	local controller = GetInstanceCreature( 724, unit:GetInstanceID(), 200631 );
	if( controller )
	then
		local vars = self[ tostring( controller ) ];
		
		-- combat in Physical realm
		vars.phase = PHASE_ONE;
	end
end

function OnDamageTaken( unit, _, attacker, damage )

	local vars = self[ tostring( unit ) ];

	local hp = unit:GetHealth();
	
    if( damage >= hp and vars.phase ~= PHASE_THREE )
	then
        damage = hp - 1;
	end
	
	if( unit:GetHealthPct() < 75 and vars.phase == PHASE_ONE )
	then
		unit:PlaySoundToSet( 17507 );
		unit:SendChatMessage( 14, 0, YELL[ 3 ] );
		unit:CancelSpell();
		
		-- combat in twilight realm
		vars.phase = PHASE_TWO;
		
		-- set not attacable
		unit:SetFlag( 0x0006 + 0x0035, 0x02000000 );
		
		-- phase spell from phase 1 to phase 2
		unit:CastSpell( SPELL_TWILIGHT_PHASING );
		
		-- hacky: summon twilight halion
		local twilightHalion = unit:SpawnCreature( 40142, 3156.67, 533.8108, 72.98822, 3.159046, 14, 0, 1, 1, 1, 1, 0 );
		
		local iid = unit:GetInstanceID();
		
		-- try to get and store twilight halion guid to use it later
		HSHARED[ iid ].dataTwilight = twilightHalion:GetGUID();
		
		-- get controller using spawnid 
		local controller = GetInstanceCreature( 724, iid, 200631 );
		if( controller )
		then
			local varsbis = self[ tostring( controller ) ];
			varsbis.phase = PHASE_TWO;
		end	
	end

	if( vars.phase == PHASE_THREE )
	then
		if( unit:GetPhase() ~= attacker:GetPhase() ) then return; end

		-- get controller using spawnid 
		local controller = GetInstanceCreature( 724, unit:GetInstanceID(), 200631 );
		if( controller )
		then
			local varsbis = self[ tostring( controller ) ];
			varsbis.materialDamageTaken = varsbis.materialDamageTaken + damage;
		end
	end
end

function OnLeaveCombat( unit )

	-- destroy table with variables to recycle resources

	self[ tostring( unit ) ] = nil;

	--[[ Developer notes: contrary to popular believe, this is the right place
	to remove ai update event since if a creature is dead the ai update will not trigger, so
	one remove ai update event its more than enough. ]]

	unit:RemoveAIUpdateEvent();

end

function OnTargetDied( unit, _, victim )

	if( victim:IsPlayer() == true )
	then
    	unit:PlaySoundToSet( 17501 );
    	unit:SendChatMessage( 14, 0, YELL[ 4 ] );
	end
end

function OnDeath( unit )

	-- destroy table with variables to recycle resources

	self[ tostring( unit ) ] = nil;

	--[[ Developer notes: we dont need to send the chat here since our
	monstersay table will do the job, instance collision checked. ]]

    unit:PlaySoundToSet( 17503 );
	
	local iid = unit:GetInstanceID();

	-- get twilight halion using guid
	local twilightHalion = GetInstanceCreature( 724, iid, HSHARED[ iid ].dataTwilight );
	if( twilightHalion )
	then
		if( twilightHalion:IsAlive() == true )
		then
			twilightHalion:Kill();
		end
	end

	-- get controller using spawnid
	local controller = GetInstanceCreature( 724, iid, 200631 );
	if( controller )
	then
		if( controller:IsAlive() == true )
		then
			controller:Kill();
		end
	end
end

function OnCastSpell( unit, event, spell_id )
	
	if( spell_id == SPELL_TWILIGHT_MENDING )
	then
		unit:SendChatMessage( 41, 0, TEXT[ 1 ] );
	end
end

local meteorStrikePos = {};

function OnAIUpdate( unit )

	local vars = self[ tostring( unit ) ];
	
	-- combat in Twilight realm
	if( vars.phase == PHASE_TWO ) then return; end

	if( unit:GetNextTarget() == nil ) then
		unit:WipeThreatList()
		return;
	end
	
	--if( unit:IsCasting() == true ) then return; end

	--if( unit:GetAIState() == 2 ) then return; end

	if( unit:GetCurrentSpell() ~= nil ) then return; end

	vars.cleave = vars.cleave - 1;
	vars.tailLash = vars.tailLash - 1;
	vars.flameBreath = vars.flameBreath - 1;
	if( flameRingTime ~= nil ) then flameRingTime = flameRingTime - 1; end
	vars.meteorStrike = vars.meteorStrike - 1;
	vars.fieryCombustion = vars.fieryCombustion - 1;

	if( vars.cleave <= 0 )
	then
		unit:CastSpell( SPELL_CLEAVE );
		vars.cleave = math.random( 6, 10 );

	elseif( vars.tailLash <= 0 )
	then
		unit:CastSpell( SPELL_TAIL_LASH );
		vars.tailLash = math.random( 7, 12 )

	elseif( vars.flameBreath <= 0 )
    then
		unit:FullCastSpell( SPELL_FLAME_BREATH );
		vars.flameBreath = math.random( 5, 15 );

	elseif( vars.flameRingTime == false and vars.flameRingTime <= 0 )
	then
		local flameRing = unit:GetGameObjectNearestCoords( 3154.99, 535.64, 72.89, 203007 );
		if( flameRing )
		then
			-- enable fire ring
			flameRing:SetByte( 0x0006 + 0x000B, 0, 1 );
			vars.flameRingTime = nil;
		end
		
	elseif( vars.meteorStrike <= 0 )
	then
		local target = unit:GetRandomPlayer( 0 );
		if( target )
		then
			local meteorStrikePos = { target:GetLocation() };
			unit:FullCastSpellAoE( meteorStrikePos[ 1 ], meteorStrikePos[ 2 ], meteorStrikePos[ 3 ], SPELL_METEOR_STRIKE );
			unit:PlaySoundToSet( 17505 );
			unit:SendChatMessage( 14, 0, YELL[ 3 ] );
		end
		vars.meteorStrike = 38;
	
	elseif( vars.fieryCombustion <= 0 )
	then
		local target = unit:GetRandomPlayer( 0 );
		if( target )
		then
			unit:CastSpellOnTarget( SPELL_FIERY_COMBUSTION, target );
		end
		vars.fieryCombustion = 25;
	end
end

RegisterUnitEvent( 39863, 18, OnSpawn );
RegisterUnitEvent( 39863, 1, OnCombat );
RegisterUnitEvent( 39863, 23, OnDamageTaken );
RegisterUnitEvent( 39863, 2, OnLeaveCombat );
RegisterUnitEvent( 39863, 3, OnTargetDied );
RegisterUnitEvent( 39863, 4, OnDeath );
RegisterUnitEvent( 39863, 29, OnCastSpell );
RegisterUnitEvent( 39863, 21, OnAIUpdate );

--[[
		Twilight Halion AI (40142)
--]]

function TwilightHalionOnSpawn( unit )

	local iid = unit:GetInstanceID();

	-- get halion using guid
	local halion = GetInstanceCreature( 724, iid, HSHARED[ iid ].dataHalion );
	if not( halion ) then return; end
	
	halion:AddAura( SPELL_COPY_DAMAGE, 0 );
	unit:AddAura( SPELL_COPY_DAMAGE, 0 );
	
	unit:CastSpell( SPELL_DUSK_SHROUD );
	
	unit:SetHealth( halion:GetHealth() );
	
	-- ToDo: set phase mask: 0x00000020 // 6 -- 32
	unit:SetPhase( 32 );
	
	-- react defensive
	unit:DisableCombat( 1 );
	
	-- set unit field flag in combat
	unit:SetFlag( 0x0006 + 0x0035, 0x00080000 );
	
end

function TwilightHalionOnCombat( unit )

	-- create protected variables
	local vars = self[ tostring( unit ) ];
	
	-- combat in twilight realm
	vars.phase = PHASE_TWO;
	
	tailLash = 12,
	soulConsumption = 15
	vars.cleave = 3;
	vars.darkBreath = 12;
	
	unit:AddAura( SPELL_TWILIGHT_PRECISION, 0 );
	
end

function TwilightHalionOnDamageTaken( unit, _, attacker, damage )

	local vars = self[ tostring( unit ) ];

	local hp = unit:GetHealth();
	
    if( damage >= hp and vars.phase ~= PHASE_THREE )
	then
        damage = hp - 1;
	end
	
	-- call on combat here? will work?
	if( vars.phase ~= PHASE_TWO and vars.phase ~= PHASE_THREE )
	then
		unit:TwilightHalionOnCombat( attacker );
	end
	
	if( unit:GetHealthPct() < 50 and vars.phase == PHASE_TWO )
	then
		unit:PlaySoundToSet( 17508 );
		unit:SendChatMessage( 14, 0, YELL[ 7 ] );
		unit:CancelSpell();
		
		-- combat in both realms
		vars.phase = PHASE_THREE;
		
		-- phase spell from phase 2 to phase 3
		unit:CastSpell( SPELL_TWILIGHT_DIVISION );
	end

	if( vars.phase == PHASE_THREE )
	then
		if( unit:GetPhase() ~= attacker:GetPhase() ) then return; end

		local controller = GetInstanceCreature( 724, unit:GetInstanceID(), 200631 );
		if( controller )
		then
			controller:SetHealth( controller:GetHealth() - damage );
			local varsbis = self[ tostring( controller ) ];
			varsbis.twilightDamageTaken = varsbis.twilightDamageTaken + damage;
		end
	end
end

function TwilightHalionOnTargetDied( unit, _, victim )

	if( victim:IsPlayer() == true )
	then
    	unit:PlaySoundToSet( 17501 );
    	unit:SendChatMessage( 14, 0, YELL[ 4 ] );
	end
	
	-- send dead player out of twilight realm
	unit:CastSpellOnTarget( SPELL_LEAVE_TWILIGHT_REALM, victim );
end

function TwilightHalionOnDeath( unit )

	-- destroy table with variables to recycle resources

	self[ tostring( unit ) ] = nil;
	
	local iid = unit:GetInstanceID();

	-- get halion using guid
	local halion = GetInstanceCreature( 724, iid, HSHARED[ iid ].dataHalion );
	if( halion )
	then
		if( halion:IsAlive() == true )
		then
			halion:Kill();
		end
	end
	
	-- get controller using spawnid 
	local controller = GetInstanceCreature( 724, iid, 200631 );
	if( controller )
	then
		if( controller:IsAlive() == true )
		then
			controller:Kill();
		end
	end
end

function TwilightHalionOnCastSpell( unit, event, spell_id )
	
	if( spell_id == SPELL_TWILIGHT_DIVISION )
	then
		local controller = GetInstanceCreature( 724, unit:GetInstanceID(), 200631 );
		if( controller )
		then
			controller:RegisterLuaEvent( ControllerDoAction, 1000, 1, 3 );
		end
	end
	
	if( spell_id == SPELL_TWILIGHT_MENDING )
	then
		unit:SendChatMessage( 41, 0, TEXT[ 1 ] );
	end
end

function TwilightHalionOnAIUpdate( unit )

	if( unit:IsCasting() == true ) then return; end

	if( unit:GetNextTarget() == nil ) then
		unit:WipeThreatList()
		return;
	end
	
	local vars = self[ tostring( unit ) ];

	vars.tailLash = vars.tailLash - 1;
	vars.soulConsumption = vars.soulConsumption - 1;
	vars.cleave = vars.cleave - 1;
	vars.darkBreath = vars.darkBreath - 1;
	
	if( vars.cleave <= 0 )
	then
		unit:CastSpell( SPELL_CLEAVE );
		vars.cleave = math.random( 7, 10 );

	elseif( vars.tailLash <= 0 )
	then
		unit:FullCastSpellOnTarget( SPELL_TAIL_LASH, unit:GetRandomPlayer( 0 ) ); -- AoE?
		vars.tailLash = math.random( 12, 16 );
	
	elseif( vars.darkBreath <= 0 )
	then
		unit:FullCastSpell( SPELL_DARK_BREATH );
		vars.darkBreath = math.random( 10, 14 );
		
	elseif( vars.soulConsumption <= 0 )
	then
		local target = unit:GetRandomPlayer( 0 );
		if( target )
		then
			unit:FullCastSpellOnTarget( SPELL_SOUL_CONSUMPTION, unit:GetRandomPlayer( 0 ) ); -- Any
		end
		vars.soulConsumption = 20;	
	end
end

RegisterUnitEvent( 40142, 18, TwilightHalionOnSpawn );
RegisterUnitEvent( 40142, 1, TwilightHalionOnCombat );
RegisterUnitEvent( 40142, 23, TwilightHalionOnDamageTaken );
RegisterUnitEvent( 40142, 3, TwilightHalionOnTargetDied );
RegisterUnitEvent( 40142, 4, TwilightHalionOnDeath );
RegisterUnitEvent( 40142, 29, TwilightHalionOnCastSpell );
RegisterUnitEvent( 40142, 21, TwilightHalionOnAIUpdate );

--[[
		Halion Controller AI (40146)
--]]

-- def unit flags 256 + 33554432 (256 for development :P)
function ControllerOnSpawn( unit )

	-- created protected variables
	self[ tostring( unit )] = {

	materialCorporealityValue = 5,
	eventStartIntro = 7,

	};
	
	-- created shared variables
	HSHARED = {}
	HSHARED[ unit:GetInstanceID() ] = {
	
	halionIsDone = false

	};

	unit:RegisterAIUpdateEvent( 1000 );

end

function ControllerOnCombat( unit )

	-- add more protected variables
	local vars = self[ tostring( unit ) ];
	
	vars.twilightDamageTaken = 0;
	vars.materialDamageTaken = 0;
	vars.triggerBerserk = 1000 * 30 * 60;
	--vars.evadeCheck = 5;
	
end

function ControllerOnLeaveCombat( unit )

	local iid = unit:GetInstanceID();

	if( SHARED[ iid ].halionIsDone == true )
	then return; end
	
	-- get twilight halion using guid
	local twilightHalion = GetInstanceCreature( 724, iid, HSHARED[ iid ].dataTwilight );
	if( twilightHalion )
	then
		twilightHalion:Despawn( 1000, 0 );
	end	

	-- get halion using guid
	local halion = GetInstanceCreature( 724, iid, HSHARED[ iid ].dataHalion );
	if( halion )
	then
		halion:Despawn( 1000, 0 );
	end
end

--[[
local WORLDSTATE_CORPOREALITY_MATERIAL = 5049;
local WORLDSTATE_CORPOREALITY_TWILIGHT = 5050;
local WORLDSTATE_CORPOREALITY_TOGGLE   = 5051;
--]]

function ControllerDoAction( unit, action )

	local vars = self[ tostring( unit ) ];
	
	-- intro halion
	if( action == 1 )
	then
		vars.eventStartIntro = 2;
		vars.phase = PHASE_INTRO;
		
	-- intro halion 2
	elseif( action == 2 )
	then
		local TREES = { 203034, 203035, 203036, 203037 };
		
		unit:SendChatMessage( 14, 0, "action 2" );
	
	-- monitor corporeality
	elseif( action == 3 )
	then
		local iid = unit:GetInstanceID();
		
		-- try to get halion using guid
		local halion = GetInstanceCreature( 724, iid, HSHARED[ iid ].dataHalion );
		if not( halion )
		then
			local vars = self[ tostring( halion ) ];
			
			-- combat in both realms
			vars.phase = PHASE_TREE;
			
			-- try to get twilight halion using guid
			local twilightHalion = GetInstanceCreature( 724, iid, HSHARED[ iid ].dataTwilight );
			if not( twilightHalion )
			then
				halion:RemoveAura( SPELL_TWILIGHT_PHASING );
			
				-- unit field flag not selectable
				halion:RemoveFlag( 0x0006 + 0x0035, 0x02000000 );
			end
		end
		
		-- summon twilight portels
		unit:CastSpell( SPELL_SUMMON_EXIT_PORTALS );
		
		-- display worldstates
		unit:SetWorldStateForZone( 5051, 1 );
		unit:SetWorldStateForZone( 5049, 50 );
		unit:SetWorldStateForZone( 5050, 50 );
		
		vars.checkCorporeality = 7;
	
	-- activate embers
	elseif( action == 4 )
	then
		vars.activateEmbers = 6;
	end
end

--[[ Developer notes: we have a problem here, since arcemu didnt implemented extra_flags why miss
CREATURE_FLAG_EXTRA_TRIGGER (creature is trigger-NPC (invisible to players only)). We can
manually make the trigger invisible but invisible creatures cast invisible spells. ]]

function ControllerOnAIUpdate( unit )

	--if( unit:GetNextTarget() == nil ) then
	--	unit:WipeThreatList();
	--	return;
	--end
	
	local vars = self[ tostring( unit ) ];

	if( vars.eventStartIntro ~= nil ) then vars.eventStartIntro = vars.eventStartIntro - 1; end
	if( vars.eventIntroProgress1 ~= nil ) then vars.eventIntroProgress1 = vars.eventIntroProgress1 - 1; end
	if( vars.eventIntroProgress2 ~= nil ) then vars.eventIntroProgress2 = vars.eventIntroProgress2 - 1; end
	if( vars.eventIntroProgress3 ~= nil ) then vars.eventIntroProgress3 = vars.eventIntroProgress3 - 1; end
	if( vars.twilightMending ~= nil ) then vars.twilightMending = vars.twilightMending - 1; end
	if( vars.triggerBerserk ~= nil ) then vars.triggerBerserk = vars.triggerBerserk - 1; end
	
	if( vars.eventStartIntro and vars.eventStartIntro <= 0 )
	then
		unit:CastSpell( SPELL_COSMETIC_FIRE_PILLAR );
		vars.eventStartIntro = nil;
		vars.eventIntroProgress1 = 4;

	elseif( vars.eventIntroProgress1 and vars.eventIntroProgress1 <= 0 )
	then
		local burningTree3 = unit:GetGameObjectNearestCoords( 3117.12, 589.134, 71.3221, 203036 );
		if( burningTree3 )
		then
			burningTree3:SetByte( 0x0006 + 0x000B, 0, 2 );
		end
		
		local burningTree4 = unit:GetGameObjectNearestCoords( 3108.75, 484.34, 71.6583, 203037 );
		if( burningTree4 )
		then
			burningTree4:SetByte( 0x0006 + 0x000B, 0, 2 );
		end
		
		vars.eventIntroProgress1 = nil
		vars.eventIntroProgress2 = 4;

	elseif( vars.eventIntroProgress2 and vars.eventIntroProgress2 <= 0 )
	then
		local burningTree1 = unit:GetGameObjectNearestCoords( 3187.96, 586.766, 73.563, 203034 );
		if( burningTree1 )
		then
			burningTree1:SetByte( 0x0006 + 0x000B, 0, 2 );
		end
		
		local burningTree2 = unit:GetGameObjectNearestCoords( 3190.34, 486.561, 71.1216, 203035 );
		if( burningTree2 )
		then
			burningTree2:SetByte( 0x0006 + 0x000B, 0, 2 );
		end
		
		vars.eventIntroProgress2 = nil;
		vars.eventIntroProgress3 = 4;
	
	elseif( vars.eventIntroProgress3 and vars.eventIntroProgress3 <= 0 )
	then
		unit:CastSpell( SPELL_FIERY_EXPLOSION );
		
		-- spawn halion
		local halion = unit:SpawnCreature( 39863, 3156.67, 533.8108, 72.98822, 3.159046, 14, 0, 1, 1, 1, 1, 0 );
		
		-- try to get and store halion guid to use it later
		HSHARED[ unit:GetInstanceID() ].dataHalion = halion:GetGUID();

		unit:PlaySoundToSet( 17499 );
    	unit:SendChatMessage( 14, 0, YELL[ 1 ] );
		
		vars.eventIntroProgress3 = nil;
		
	elseif( vars.twilightMending and vars.twilightMending <= 0 )
	then
		local iid = unit:GetInstanceID();
		
		-- get twilight halion using guid
		local twilightHalion = GetInstanceCreature( 724, iid, SHARED[ iid ].dataTwilight );
		if( twilightHalion )
		then
			twilightHalion:CastSpell( SPELL_TWILIGHT_MENDING );
		end
	
	elseif( vars.triggerBerserk and vars.triggerBerserk <= 0 )
	then
		local iid = unit:GetInstanceID();
		
		-- get halion using guid
		local halion = GetInstanceCreature( 724, iid, SHARED[ iid ].dataHalion );
		if( halion )
		then
			halion:CastSpell( SPELL_BERSERK );
		end
		
		-- get twilight halion using guid
		local twilightHalion = GetInstanceCreature( 724, iid, SHARED[ iid ].dataTwilight );
		if( twilightHalion )
		then
			twilightHalion:CastSpell( SPELL_BERSERK );
		end
		
	elseif( vars.shadowPulsars and vars.shadowPulsars <= 0 )
	then
		-- ToDo
		vars.shadowPulsars = 30;
	
	elseif( vars.checkCorporeality and vars.checkCorporeality <= 0 )
	then
		UpdateCorporeality( unit );
		vars.checkCorporeality = 5;
	
	elseif( vars.activateEmbers and vars.activateEmbers <= 0 )
	then
		-- ToDo
		
	--[[elseif( vars.evadeCheck <= 0 )
	then
		-- ToDo
		vars.evadeCheck = 5; --]]
	end
end

function UpdateCorporeality( unit )
	
	local vars = self[ tostring( unit ) ];
	
	local oldValue = vars.materialCorporealityValue;
	
	if( vars.twilightDamageTaken == 0 or vars.materialDamageTaken == 0 )
	then
		vars.twilightMending = 0.1;
		return;	end

	local damageRatio = vars.materialDamageTaken / vars.twilightDamageTaken;
	
	 -- corporeality none
	local action = 0;
	
	if( damageRatio <= 0.98 )
	then
		-- corporeality decrease
		action = 3 ;
		
	elseif( 0.99 < damageRatio and damageRatio < 1.01 )
	then
		-- corporeality twilight mending
		action = 1;
	
	elseif( 1.02 < damageRatio )
	then
		-- corporeality increase
		action = 2;
	end
	
	-- corporeality none
	if( action == 0 )
	then
		vars.materialDamageTaken = 0;
		vars.twilightDamageTaken = 0;
		return;
	
	-- corporeality increase
	elseif( action == 2 )
	then
		if( vars.materialCorporealityValue >= 11 - 1 ) then	return; end
		
		vars.materialCorporealityValue = vars.materialCorporealityValue + 1;
	
	-- corporeality decrease
	elseif( action == 3 )
	then
		if( vars.materialCorporealityValue <= 0 ) then return; end
		
		vars.materialCorporealityValue = vars.materialCorporealityValue - 1;
	
	-- corporeality twilight mending
	elseif( action == 1 )
	then
		vars.twilightMending = 0.1;
		vars.materialDamageTaken = 0;
		vars.twilightDamageTaken = 0;
		return; 
	end
	
	vars.materialDamageTaken = 0;
    vars.twilightDamageTaken = 0;
	
	unit:SetWorldStateForZone( 5049, vars.materialCorporealityValue * 10 );
	unit:SetWorldStateForZone( 5050, 100 - vars.materialCorporealityValue * 10 );
	
end

RegisterUnitEvent( 40146, 18, ControllerOnSpawn );
RegisterUnitEvent( 40146, 1, ControllerOnCombat );
RegisterUnitEvent( 40146, 2, ControllerOnLeaveCombat );
RegisterUnitEvent( 40146, 21, ControllerOnAIUpdate );

--print( "Lua memory after Halion: "..gcinfo().." Kb." );

--[[
		Spell: Twilight Phasing (74808)


function SpellHalionTwilightPhasing( _, _, spellid, spellObject )

	if( spellid == 74808 )
	then
		local caster = spellObject:GetCaster();
		local x = caster:GetX();
		local y = caster:GetY();
		local z = caster:GetZ();
		local o = caster:GetO();

	caster:CastSpellAoE( x, y, z, SPELL_SUMMON_TWILIGHT_PORTAL );
	caster:SpawnCreature( 40142, x, y, z, o, 14, 0, 1, 1, 1, 1, 0 );

	end
end

RegisterServerHook( 33, SpellHalionTwilightPhasing );
--]]
--[[ 
		Debug commands disabled by default


local COMMANDS = { "halion", "port", "exit", "open", "close", "hp75", "hp50", "action1", "action2", "action3", "action4" };

function Commands( _, plr, message )

	if( plr:IsGm() == true )
	then
		if( message == "#halion" )
		then
			for i = 1, #COMMANDS
			do
				plr:SendBroadcastMessage( ""..COMMANDS[ i ].."" );
			end

		elseif( message == "#port" )
		then
			plr:Teleport( 724, 3190.85, 637.78, 78.93, 3.11 );
			
		elseif( message == "#exit" )
		then
			plr:Teleport( 571, 3597.61, 200.96, -113.74, 5.30 );
			
		elseif( message == "#open" )
		then
			local flameRing = plr:GetGameObjectNearestCoords( 3154.99, 535.64, 72.89, 203007 );
			flameRing:SetByte( 0x0006 + 0x000B, 0, 0 );
		
		elseif( message == "#close" )
		then
			local flameRing = plr:GetGameObjectNearestCoords( 3154.99, 535.64, 72.89, 203007 );
			flameRing:SetByte( 0x0006 + 0x000B, 0, 1 );
			
		else
		
			local selection = plr:GetSelection();
			if( selection == nil)
			then
				plr:SendBroadcastMessage( "You need to select something first." );
				
			else		

				if( message == "#hp75" )
				then
					selection:SetHealthPct( 75 );

					
				elseif( message == "#hp50" )
				then
					selection:SetHealthPct( 50 );
					
				elseif( message == "#m" )
				then
					local iid = plr:GetInstanceID();
					local controller = GetInstanceCreature( 724, iid, 200631 );
					local p = self[ tostring( controller ) ].phase
					
					plr:SendBroadcastMessage( ""..p.."" );
					
				elseif( message == "#action1" )
				then 
					selection:RegisterLuaEvent( ControllerDoAction, 1000, 1, 1 );
				
				elseif( message == "#action2" )
				then 
					selection:RegisterLuaEvent( ControllerDoAction, 1000, 1, 2 );
				
				elseif( message == "#action3" )
				then 
					selection:RegisterLuaEvent( ControllerDoAction, 1000, 1, 3 );

				elseif( message == "#action4" )
				then 
					selection:RegisterLuaEvent( ControllerDoAction, 1000, 1, 4 );	
					
				elseif( message == "#mending" )
				then
					local vars = self[ tostring( selection ) ];
					vars.triggerBerserk = 3;
				end
			end
		end
	end
end

RegisterServerHook( 16, Commands );--]]